
## 第四章   变量、 作用域 和内存问题

2018-7-31  page-79

@ 在很多语言中，字符串是 对象的形式存在的 ,但是JS 放弃这一个做法 ===> why
@ 为什么OC 中用的引用计数，而JS 中用清除标记(居然说引用计数不好)

#####4.1 基本类型和引用类型的值 

- 数据类型
	- 基本类型 Undefined Null String Number Boolen （注意都是大写）-> 栈区
	- 引用类型 


- 检测类型 
	- 基本类型 用 typeof  引用类型用 instanceof  (列外 null -> Object)

- 执行环境 与 作用域  作用域链
	> 执行环境:(全局window 局部 func内部)
		 就是 当前 函数 或则 当前 js代码 所处的环境, 
		一般最外面就是window ,函数 就是 调用函数的对象，也就是 this 指的是谁(只需要 看 funName() 的点号前面 跟的是谁就好了，apply call bind，除外，另外讨论)
			- call ,apply,就是改变函数 this的指向问题，区别就是后面跟的参数的形式不一样
			  bind 是直接把某个func 绑定在 作用域上，this 就是固定的了.
			  func.call(obj,xxx) 				this 指的是obj
			  func.bind(obj1); obj2.func();		this 仍然指的是 obj1
	  作用域链：
	  	使用一个 函数 或则一个 变量的时候，通常先从 变量的当前作用找，找不到再往上一层去找，直到window，若还没有，那就是 没有，这种逐级寻找的 顺利，就是作用域链

- 延长 作用域 
	- with （具体也很少用，也不推荐用 with ）和 cry-catch

- 块级作用域
	- ES5 没有块级作用域 (块级作用域即使 {}里面，所以，除了 全局与局部，没有块级作用域,记住下面两个案列即可
	```
	if(true){
		var abc = 9;
	}
	alert(abc) //9
	for(var i=0;i++;i<10){
	}
	alert(i) // i = 10
	```
	- ES6 是有块级作用域

- 变量的声明， 不用 var，直接令名
```
abc = 9; //那么就是全局变量 window.abc  禁止这么用，不可阅读
```



- 垃圾收集 机制
	- 清除标记，
	有一个 标记list(存储 所有的变量和函数)，当进入一个 环境，把所有的变量放到 list ，然后取出所有的当前环境在用的，和引用的。过一段时间 定时清理 list 中的变量 的内存

	- 引用计数
	给每个变量 计数，被引用一次 +1 ，被释放一次 -1，当变成 0 的时候，系统自动回收

	为题是：会出现循环引用



